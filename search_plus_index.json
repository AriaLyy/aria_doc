{"./":{"url":"./","title":"Introduction","keywords":"","body":" Aria下载框架中文文档 本文档适用于3.4版本 "},"start/start.html":{"url":"start/start.html","title":"1.1 开始","keywords":"","body":"开始导入aria在AndroidManifest文件中添加相应权限注册aria启动任务接受任务回调开始 导入aria 在app目录下的build.gradle文件中添加以下依赖 compile 'com.arialyy.aria:aria-core:3.4' annotationProcessor 'com.arialyy.aria:aria-compiler:3.4' 如果出现android support，请将 compile 'com.arialyy.aria:aria-core:'替换为 compile('com.arialyy.aria:aria-core:'){ exclude group: 'com.android.support' } 如果你使用的是kotlin，请使用kotlin官方提供的方法配置apt，kotlin kapt官方配置传送门 在AndroidManifest文件中添加相应权限 由于Aria涉及到文件和网络的操作，因此需要你在manifest文件中添加以下权限，如果你希望在6.0以上的系统中使用Aria，那么你需要动态向安卓系统申请文件系统读写权限，如何使用安卓系统权限 注册aria 在Activity的onCreate、fragment的onCreate、java的构造函数中使用Aria.download(this).register();便可以实现注册。 如在activity中： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Aria.download(this).register(); } 启动任务 Aria.download(this) .load(DOWNLOAD_URL) //读取下载地址 .setDownloadPath(DOWNLOAD_PATH) //设置文件保存的完整路径 .start(); //启动下载 接受任务回调 基于解耦合的考虑，Aria的下载功能是和状态获取相分离的，状态的获取并不会集成到链式代码中，但是Aria提供了另一种更简单更灵活的方案。 通过注解，你可以很容易获取任务的所有状态。 //在这里处理任务执行中的状态，如进度进度条的刷新 @Download.onTaskRunning protected void running(DownloadTask task) { if(task.getUrl().eques(url)){ .... 可以通过url判断是否是指定任务的回调 } int p = task.getPercent(); //任务进度百分比 String speed = task.getConvertSpeed(); //转换单位后的下载速度，单位转换需要在配置文件中打开 String speed1 = task.getSpeed(); //原始byte长度速度 } @Download.onTaskComplete void taskComplete(DownloadTask task) { //在这里处理任务完成的状态 } 注意： 注解回掉采用Apt的方式实现，所以，你不需要担心这会影响你机器的性能 被注解的方法不能被private修饰 被注解的方法只能有一个参数，并且参数类型必须是DownloadTask或UploadTask或DownloadGroupTask 方法名可以为任意字符串 "},"start/config.html":{"url":"start/config.html","title":"1.2 配置","keywords":"","body":"Aria参数配置配置文件设置参数代码中设置参数一些参数说明执行队列类型设置最大任务数说明（Wait模式下的说明）Aria参数配置 在Aria中，你可以在配置文件或调用Aria代码配置Aria的参数。 配置文件设置参数 创建aria_config.xml 文件，将其放在assets目录下 代码中设置参数 除了文件方式外修改Aria参数外，同样的，你也可以在代码中动态修改Aria参数 通过Aria.get(this).getDownloadConfig()或Aria.get(this).getUploadConfig()直接获取配置文件，然后修改参数 如以下所示： // 修改最大下载数，调用完成后，立即生效 // 如当前下载任务数是4，修改完成后，当前任务数会被Aria自动调度任务数 Aria.get(this).getDownloadConfig().setMaxTaskNum(3); 一些参数说明 执行队列类型 wait模式 队列模式为等待模式。 当正在执行的任务数已经达到队列设置的最大任务数时，继续下载新任务，Aria则会把新任务缓存到缓存队列中 now模式 队列模式为优先下载模式。 当正在执行的任务数已经达到队列设置的最大任务数时，继续下载新任务，Aria会停止执行队列中的队首任务，新任务会立刻下载 设置最大任务数说明（Wait模式下的说明） 如果你在下载任务中最大任务数设置为3 当你连续下载的任务数小于3，任务会自动执行 当正在执行的任务有3个时，如果你继续开始新任务，Aria则会将新任务存放在缓存队列中 当正在执行的任务数有3个时，并且缓存队列中有1个任务，这时，如果你调用setMaxTaskNum(4);接口将最大任务数设置为4，则Aria会自动执行缓存队列中的任务，直到正在执行的任务数达到最大任务数为止 如果正在执行的任务数有3个，这时，如果你调用setMaxTaskNum(2);接口将最大任务数设置为2，那么Aria会自动停止正在执行的队列中的第一个任务。 在Aria中，上传任务和下载任务的最大任务数相互独立，互不影响的。 如：在上传类型的任务中，设置的最大的上传任务数为2，同时设置的最大下载任务为4。那么在下载队列中连续打开4个任务也不会暂停任何一个上传任务。 "},"start/any_java.html":{"url":"start/any_java.html","title":"1.3 在任意类中使用Aria","keywords":"","body":"在任意java类中使用aria初始化Aria在module类的构造函数中注册Aria注意事项demo在任意java类中使用aria 从3.4版本开始，Aria支持在任意java类中使用 初始化Aria 在Application调用Aria的初始化方法。 Aria.init(this); 在module类的构造函数中注册Aria Aria.download(this).register(); 注意事项 在Activity销毁时需要在modlue中调用unRegister销毁事件。 如果不进行销毁操作，将会导致内存泄露！！ Aria.download(this).unRegister(); demo public class AnyRunnModule { String TAG = \"AnyRunnModule\"; private Context mContext; private String mUrl; public AnyRunnModule(Context context) { Aria.download(this).register(); mContext = context; } @Download.onWait void onWait(DownloadTask task) { Log.d(TAG, \"wait ==> \" + task.getDownloadEntity().getFileName()); } @Download.onPre protected void onPre(DownloadTask task) { Log.d(TAG, \"onPre\"); } @Download.onTaskStart void taskStart(DownloadTask task) { Log.d(TAG, \"onStart\"); } @Download.onTaskRunning protected void running(DownloadTask task) { Log.d(TAG, \"running\"); } @Download.onTaskResume void taskResume(DownloadTask task) { Log.d(TAG, \"resume\"); } @Download.onTaskStop void taskStop(DownloadTask task) { Log.d(TAG, \"stop\"); } @Download.onTaskCancel void taskCancel(DownloadTask task) { Log.d(TAG, \"cancel\"); } @Download.onTaskFail void taskFail(DownloadTask task) { Log.d(TAG, \"fail\"); } @Download.onTaskComplete void taskComplete(DownloadTask task) { L.d(TAG, \"path ==> \" + task.getDownloadEntity().getDownloadPath()); L.d(TAG, \"md5Code ==> \" + CommonUtil.getFileMD5(new File(task.getDownloadPath()))); } void start(String url) { mUrl = url; Aria.download(this) .load(url) .addHeader(\"Accept-Encoding\", \"gzip, deflate\") .setRequestMode(RequestEnum.GET) .setFilePath(Environment.getExternalStorageDirectory().getPath() + \"/ggsg1.apk\") .resetState() .start(); } void stop() { Aria.download(this).load(mUrl).stop(); } void cancel() { Aria.download(this).load(mUrl).cancel(); } void unRegister() { Aria.download(this).unRegister(); } } "},"start/task_explain.html":{"url":"start/task_explain.html","title":"1.4 任务说明","keywords":"","body":"任务说明任务队列说明任务的生命周期任务说明 在Aria中，根据功能的不同划分了6种不同的任务，分别是： HTTP下载任务 HTTP组合任务 FTP下载任务 FTP文件夹下载任务 HTTP上传任务 FTP上传任务 普通任务 其中HTTP下载任务、FTP下载任务、HTTP上传任务、FTP上传任务为普通任务。所谓普通任务就是一个链接对应一个文件，如： HTTP下载任务，一个下载地址对应一个文件下载 特殊任务 而HTTP组合任务属于特殊任务，由多个HTTP下载任务组合而成，共享同一进度，如： 如下载一个视频A，还需要下载视频文件、字幕、视频截图，这三个文件对应的都属于视频A，需要共用同一进度条，那么这时应该使用HTTP组合任务 FTP文件下载任务，意思是，传入一个FTP文件夹地址，将下载该文件夹下对应的所有文件，进度为: 已下载的文件长度的总和 任务队列说明 在Aria中，所有的上传\\下载操作都是一个任务，用户添加的任务时，Aria首先都会进入到cache_queue中： 如果run_queue没满，则会马上执行该任务 如果run_queue已满，aria会回调onWait方法 当任务完成、停止、失败，run_queue将会将任务出队，并回调相应的方法，然后从cache_queue中提取等待中的任务执行 run_queue大小配置 任务的生命周期 如上图所示，每一个任务都有自己的生命周期，任务处于生命周期不同的阶段回调对应的方法 "},"start/annotation_explain.html":{"url":"start/annotation_explain.html","title":"1.5 注解说明","keywords":"","body":"注意事项HTTP\\FTP单任务下载注解HTTP组合任务下载\\FTP文件夹下载注解组合任务中子任务注解HTTP\\FTP单任务上传注解tip注意事项 除了在widget（Activity、Fragment、Dialog、Popupwindow）中使用注解方法外，你还可以在Service、Notification等组件中使用注解函数。 注意： 注解回掉采用Apt的方式实现，所以，你不需要担心这会影响你机器的性能 被注解的方法不能被private修饰 被注解的方法只能有一个参数，并且参数类型必须是DownloadTask或UploadTask或DownloadGroupTask 方法名可以为任意字符串 HTTP\\FTP单任务下载注解 注解 说明 示例 @Download.onPre 预处理的注解，在任务为开始前回调（一般在此处预处理UI界面） @Download.onPre void onPre(DownloadTask task) {} @Download.onTaskStart 任务开始时的注解，新任务开始时进行回调 @Download.onTaskStart void taskStart(DownloadTask task) {} @Download.onTaskResume 任务恢复时的注解，任务从停止恢复到运行前进行回调 @Download.onTaskResume void taskResume(DownloadTask task) {} @Download.onTaskRunning 任务执行时的注解，任务正在执行时进行回调 @Download.onTaskRunning void running(DownloadTask task) {} @Download.onWait 队列已经满了，继续创建新任务，将会回调该方法 @Download.onWait void onWait(DownloadTask task){} @Download.onTaskStop 任务停止时的注解，任务停止时进行回调 @Download.onTaskStop void taskStop(DownloadTask task) {} @Download.onTaskCancel 任务被删除时的注解，任务被删除时进行回调 @Download.onTaskCancel void taskCancel(DownloadTask task) {} @Download.onTaskFail 任务失败时的注解，任务执行失败时进行回调 @Download.onTaskFail void taskFail(DownloadTask task) {} @Download.onTaskComplete 任务完成时的注解，任务完成时进行回调 @Download.onTaskComplete void taskComplete(DownloadTask task) {} @Download.onNoSupportBreakPoint 这是一个特殊的注解，用于处理不支持断点续传的任务 @Download.onNoSupportBreakPoint void onNoSupportBreakPoint(DownloadTask task) {} HTTP组合任务下载\\FTP文件夹下载注解 注解 说明 示例 @DownloadGroup.onPre 预处理的注解，在任务为开始前回调（一般在此处预处理UI界面） @DownloadGroup.onPre void onPre(DownloadGroupTask task) {} @DownloadGroup.onTaskStart 任务开始时的注解，新任务开始时进行回调 @DownloadGroup.onTaskStart void taskStart(DownloadGroupTask task) {} @DownloadGroup.onTaskResume 任务恢复时的注解，任务从停止恢复到运行前进行回调 @DownloadGroup.onTaskResume void taskResume(DownloadGroupTask task) {} @DownloadGroup.onTaskRunning 任务执行时的注解，任务正在执行时进行回调 @DownloadGroup.onTaskRunning void running(DownloadGroupTask task) {} @DownloadGroup.onWait 队列已经满了，继续创建新任务，将会回调该方法 @DownloadGroup.onWait void onWait(DownloadGroupTask task){} @DownloadGroup.onTaskStop 任务停止时的注解，任务停止时进行回调 @DownloadGroup.onTaskStop void taskStop(DownloadGroupTask task) {} @DownloadGroup.onTaskCancel 任务被删除时的注解，任务被删除时进行回调 @DownloadGroup.onTaskCancel void taskCancel(DownloadGroupTask task) {} @DownloadGroup.onTaskFail 任务失败时的注解，任务执行失败时进行回调 @DownloadGroup.onTaskFail void taskFail(DownloadGroupTask task) {} @DownloadGroup.onTaskComplete 任务完成时的注解，任务完成时进行回调 @DownloadGroup.onTaskComplete void taskComplete(DownloadGroupTask task) {} 组合任务中子任务注解 注解 说明 示例 @DownloadGroup.onSubTaskRunning 任务组子任务下载中时回调 @DownloadGroup.onSubTaskRunning void onSubTaskRunning(DownloadGroupTask groupTask, DownloadEntity subEntity) {} @DownloadGroup.onSubTaskPre 任务组子任务预处理时回调 @DownloadGroup.onSubTaskPre void onSubTaskRunning(DownloadGroupTask groupTask, DownloadEntity subEntity) {} @DownloadGroup.onSubTaskStop 任务组子任务停止时回调 @DownloadGroup.onSubTaskStop void onSubTaskRunning(DownloadGroupTask groupTask, DownloadEntity subEntity) {} @DownloadGroup.onSubTaskStart 任务组子任务开始下载时回调 @DownloadGroup.onSubTaskStart void onSubTaskRunning(DownloadGroupTask groupTask, DownloadEntity subEntity) {} @DownloadGroup.onSubTaskComplete 任务组子任务完成时时回调 @DownloadGroup.onSubTaskComplete void onSubTaskRunning(DownloadGroupTask groupTask, DownloadEntity subEntity) {} @DownloadGroup.onSubTaskFail 任务组子任务执行失败时回调 @DownloadGroup.onSubTaskFail void onSubTaskRunning(DownloadGroupTask groupTask, DownloadEntity subEntity) {} HTTP\\FTP单任务上传注解 注解 说明 示例 @Upload.onPre 预处理的注解，在任务为开始前回调（一般在此处预处理UI界面） @Upload.onPre void onPre(UploadTask task) {} @Upload.onTaskStart 任务开始时的注解，新任务开始时进行回调 @Upload.onTaskStart void taskStart(UploadTask task) {} @Upload.onTaskResume 任务恢复时的注解，任务从停止恢复到运行前进行回调 @Upload.onTaskResume void taskResume(UploadTask task) {} @Upload.onTaskRunning 任务执行时的注解，任务正在执行时进行回调 @Upload.onTaskRunning void running(UploadTask task) {} @Upload.onWait 队列已经满了，继续创建新任务，将会回调该方法 @Upload.onWait void onWait(UploadTask task){} @Upload.onTaskStop 任务停止时的注解，任务停止时进行回调 @Upload.onTaskStop void taskStop(UploadTask task) {} @Upload.onTaskCancel 任务被删除时的注解，任务被删除时进行回调 @Upload.onTaskCancel void taskCancel(UploadTask task) {} @Upload.onTaskFail 任务失败时的注解，任务执行失败时进行回调 @Upload.onTaskFail void taskFail(UploadTask task) {} @Upload.onTaskComplete 任务完成时的注解，任务完成时进行回调 @Upload.onTaskComplete void taskComplete(UploadTask task) {} tip TIP：如果你子希望对单个任务，或某一些特定任务设置监听器。 可以在注解中添加任务的下载地址，则表示只有该任务才会触发被注解的方法__。 @Download.onTaskRunning({ \"https://test.xx.apk\", \"http://test.xx2.apk\" }) void taskRunning(DownloadTask task) { mAdapter.setProgress(task.getDownloadEntity()); } 在上面的例子中，只有下载地址是https://test.xx.apk和http://test.xx2.apk才会触发 taskRunning(DownloadTask task)方法。 除了用注解判断任务外，你还可以使用task.getKey()来判断当前任务，getKey()返回的是下载地址或上传任务 @Download.onTaskRunning void taskRunning(DownloadTask task) { if(task.getKey().eques(DOWNLOAD_URL)){ mAdapter.setProgress(task.getDownloadEntity()); } } "},"download/http_normal.html":{"url":"download/http_normal.html","title":"2.1 HTTP下载","keywords":"","body":"普通任务操作任务控制普通任务操作 任务控制 事件注解 下载\\恢复下载 Aria.download(this) .load(DOWNLOAD_URL) //读取下载地址 .setDownloadPath(DOWNLOAD_PATH) //设置文件保存的完整路径 .setRequestMode(RequestEnum.POST) // 设置请求类型 .start(); //启动下载 暂停 Aria.download(this).load(DOWNLOAD_URL).pause(); 取消下载 Aria.download(this).load(DOWNLOAD_URL).cancel(); 设置头部参数 Aria.download(this).load(DOWNLOAD_URL).addHeader(\"key\", \"value\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).load(DOWNLOAD_URL).addHeader(\"key\", \"value\").save(); 设置扩展字段 有的时候，你可能希望在下载的时候存放一些自己的数据，这时你可以调用该接口将数据保存下来（如果你数据比较多，或者数据比较复杂，你可以先把数据转换为JSON，然后再将其存到Aria的下载实体中） Aria.download(this).load(DOWNLOAD_URL).setExtendField(\"扩展字段\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).load(DOWNLOAD_URL).setExtendField(\"扩展字段\").save(); "},"download/http_group.html":{"url":"download/http_group.html","title":"2.2 HTTP组合任务下载","keywords":"","body":"http组合任务组合任务控制组合任务子任务操作http组合任务 任务组的下载和普通任务的下载基本上差不多，区别在于，任务组下载不需要对每一个子任务设置保存路径，但是需要设置任务组保存文件夹路径，所有子任务都保存在该文件夹下 组合任务控制 组合任务注解 下载\\恢复下载 Aria.download(this) .loadGroup(urls) //设置一主任务，参数为List .setDirPath(groupDirPath) //设置任务组的文件夹路径 /* * 任务组总任务大小，任务组是一个抽象的概念，没有真实的数据实体，任务组的大小是Aria动态获取子任务大小相加而得到的， * 如果你知道当前任务组总大小，你也可以调用该方法给任务组设置大小 * * 为了更好的用户体验，建议直接设置任务组文件大小 */ .setFileSize(fileSize) .start(); //启动下载 暂停 Aria.download(this).loadGroup(urls).pause(); 取消下载 Aria.download(this).loadGroup(urls).cancel(); 设置头部参数 在任务组中，设置的头部参数将用于所有的子任务 Aria.download(this).loadGroup(urls).addHeader(\"key\", \"value\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).loadGroup(urls).addHeader(\"key\", \"value\").save(); 设置扩展字段 有的时候，你可能希望在下载的时候存放一些自己的数据，这时你可以调用该接口将数据保存下来（如果你数据比较多，或者数据比较复杂，你可以先把数据转换为JSON，然后再将其存到Aria的下载实体中） Aria.download(this).loadGroup(urls).setExtendField(\"扩展字段\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).loadGroup(urls).setExtendField(\"扩展字段\").save(); 组合任务子任务操作 子任务注解 启动组合任务中的一个子任务 Aria.download(getContext()).loadGroup(mUrls).getSubTaskManager().startSubTask(mChildEntity.getUrl()); 停止组合任务中的一个子任务 Aria.download(getContext()).loadGroup(mUrls).getSubTaskManager().stopSubTask(mChildEntity.getUrl()); "},"download/ftp_normal.html":{"url":"download/ftp_normal.html","title":"2.3 ftp下载","keywords":"","body":"ftp下载ftp控制注意事项ftp下载 ftp控制 FTP任务注解 开始\\恢复下载 Aria.download(this) .loadFtp(\"ftp://192.18.104.129:21/haha/large.rar\") .login(\"lao\", \"123456\") //登录FTP服务器 .setFilePath(\"/mnt/sdcard/\") //设置文件保存文件夹 .start(); 暂停 Aria.download(this).loadFtp(URL).stop(); 删除任务 Aria.download(this).loadFtp(URL).cancel(); 设置扩展字段 有的时候，你可能希望在下载的时候存放一些自己的数据，这时你可以调用该接口将数据保存下来（如果你数据比较多，或者数据比较复杂，你可以先把数据转换为JSON，然后再将其存到Aria的下载实体中） Aria.download(this).loadFtp(URL).setExtendField(\"扩展字段\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).loadFtp(URL).setExtendField(\"扩展字段\").save(); 注意事项 FTP下载必须加上端口号 aria支持读取url中的账号和密码，但是如果url中已经带有账号和密码，则不能使用login()进行登录，否则url中的账号密码将被覆盖 对于公网上盗版资源的ftp链接，不能保证一定能下载成功，因为这些盗版资源在会经常性被删除。而迅雷之所以能下载，是因为迅雷有自己的资源库，一个链接不通，它可能有另外的链接进行下载 "},"download/ftp_dir.html":{"url":"download/ftp_dir.html","title":"2.4 ftp文件夹下载","keywords":"","body":"FTP文件夹下载FTP任务控制注意事项FTP文件夹下载 FTP任务控制 事件注解 开始\\恢复下载 Aria.download(this) .loadFtpDir(\"ftp://172.18.104.129:21/haha/\") .setDirPath(downloadPath) .login(\"lao\", \"123456\") .start(); 暂停 Aria.download(this).loadFtpDir(dir).stop(); 删除任务 Aria.download(this).loadFtpDir(dir).cancel(); 设置扩展字段 有的时候，你可能希望在下载的时候存放一些自己的数据，这时你可以调用该接口将数据保存下来（如果你数据比较多，或者数据比较复杂，你可以先把数据转换为JSON，然后再将其存到Aria的下载实体中） Aria.download(this).loadFtp(URL).setExtendField(\"扩展字段\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).loadFtp(URL).setExtendField(\"扩展字段\").save(); 注意事项 FTP下载必须加上端口号 aria支持读取url中的账号和密码，但是如果url中已经带有账号和密码，则不能使用login()进行登录，否则url中的账号密码将被覆盖 对于公网上盗版资源的ftp链接，不能保证一定能下载成功，因为这些盗版资源在会经常性被删除。而迅雷之所以能下载，是因为迅雷有自己的资源库，一个链接不通，它可能有另外的链接进行下载 "},"upload/http_normal.html":{"url":"upload/http_normal.html","title":"3.1 http上传","keywords":"","body":"http上传任务控制注意事项http上传 任务控制 事件注解 添加任务(只添加，不上传) Aria.upload(this) .load(filePath) //文件路径 .setDownloadPath(DOWNLOAD_PATH) //设置文件保存的完整路径 .setUploadUrl(uploadUrl) //上传路径 .setAttachment(fileKey) //服务器读取文件的key .add(); 上传 Aria.upload(this) .load(filePath) //文件路径 .setUploadUrl(uploadUrl) //上传路径 .setAttachment(fileKey) //服务器读取文件的key .start(); 取消上传 Aria.upload(this).load(filePath).cancel(); 设置头部参数 Aria.download(this).load(DOWNLOAD_URL).addHeader(\"key\", \"value\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).load(DOWNLOAD_URL).addHeader(\"key\", \"value\").save(); 设置扩展字段 有的时候，你可能希望在下载的时候存放一些自己的数据，这时你可以调用该接口将数据保存下来（如果你数据比较多，或者数据比较复杂，你可以先把数据转换为JSON，然后再将其存到Aria的下载实体中） Aria.download(this).load(DOWNLOAD_URL).setExtendField(\"扩展字段\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).load(DOWNLOAD_URL).setExtendField(\"扩展字段\").save(); 注意事项 由于HTTP的特性，没法实现一个通用的断点上传方式，因此HTTP上传不支持暂停，每次调用start()方法都会重新执行 如果你需要在上传文件的时候获取服务器返回的数据，那么你可以在onTaskComplete注解中通过实体getResponseStr()获取返回数，如下所示： @Upload.onTaskComplete public void taskComplete(UploadTask task) { L.d(TAG, \"上传完成\"); L.d(TAG, \"上传成功返回数据（如果有的话）：\" + task.getEntity().getResponseStr()); } "},"upload/ftp_normal.html":{"url":"upload/ftp_normal.html","title":"3.2 ftp上传","keywords":"","body":"FTP单文件上传任务控制注意事项FTP单文件上传 任务控制 事件注解 开始\\恢复上传 Aria.upload(this) .loadFtp(\"/mnt/sdcard/gggg.apk\") //上传文件路径 .setUploadUrl(URL) //上传的ftp服务器地址 .login(\"lao\", \"123456\") .start(); 暂停 Aria.upload(this).loadFtp(FILE_PATH).stop(); 删除任务 Aria.upload(this).loadFtp(FILE_PATH).cancel(); 设置扩展字段 有的时候，你可能希望在下载的时候存放一些自己的数据，这时你可以调用该接口将数据保存下来（如果你数据比较多，或者数据比较复杂，你可以先把数据转换为JSON，然后再将其存到Aria的下载实体中） Aria.download(this).loadFtp(URL).setExtendField(\"扩展字段\").start(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).loadFtp(URL).setExtendField(\"扩展字段\").save(); 注意事项 FTP上传需要FTP 服务器给用户打开write的权限 如果需要支持断点上传，需要FTP服务器给用户打开append权限 FTP下载必须加上端口号 aria支持读取url中的账号和密码，但是如果url中已经带有账号和密码，则不能使用login()进行登录，否则url中的账号密码将被覆盖 "},"api/task_list.html":{"url":"api/task_list.html","title":"4.1 获取任务列表","keywords":"","body":"获取任务列表 下载 获取所有普通下载任务，包括已完成和为完成的普通任务List list = Aria.download(this).getTaskList(); 获取所有未完成的普通下载任务List list = Aria.download(this).getAllNotCompletTask(); 获取所有已经完成的普通任务List list = Aria.download(this).getAllCompleteTask(); 获取组合任务列表List group = Aria.download(this).getGroupTaskList(); 获取所有任务的任务列表List list = Aria.download(this).getTotalTaskList(); 上传 获取所有普通下载任务，包括已完成和为完成的普通任务List list = Aria.upload(this).getTaskList(); 获取所有未完成的普通下载任务List list = Aria.upload(this).getAllNotCompletTask(); 获取所有已经完成的普通任务List list = Aria.upload(this).getAllCompleteTask(); "},"api/task_handle.html":{"url":"api/task_handle.html","title":"4.2 常用的任务操作","keywords":"","body":"停止所有正在下载的任务 停止所有任务的命令，并清空所有等待队列 Aria.download(this).stopAllTask(); 或 Aria.upload(this).stopAllTask(); 恢复所有停止的任务 如果执行队列没有满，则开始下载任务，直到执行队列满 如果队列执行队列已经满了，则将所有任务添加到等待队列中Aria.download(this).resumeAllTask(); 或 Aria.upload(this).resumeAllTask(); 删除所有任务 Aria.download(this).removeAllTask(); 或 Aria.upload(this).removeAllTask(); 如果任务为完成，会删除没有完成的文件 如果使用removeAllTask(true)方法，会将已经下载完成和未完成的文件删除 如果是上传任务，不会删除本地的上传文件，但如果使用removeAllTask(true)，同样会删除本地上传文件 获取任务当前状态 Aria.download(this).getTaskState(); 或 Aria.upload(this).getTaskState(); 状态码 说明 -1 未知状态 0 失败 1 成功 2 停止 3 等待 4 执行中 5 预处理 6 预处理完成 7 删除任务 删除单个任务 /** * 删除任务 * * @param removeFile {@code true} 不仅删除任务数据库记录，还会删除已经删除完成的文件 * {@code false}如果任务已经完成，只删除任务数据库记录， */ Aria.download(this).cancel(true); 或 Aria.upload(this).cancel(true); 重置任务状态 状态重置之后，任务将重新开始执行 Aria.download(this).resetState(); 或 Aria.upload(this).resetState(); 修改文件保存信息 设置文件存储路径，如果需要修改新的文件名，修改路径便可。 如：原文件路径 /mnt/sdcard/test.zip 如果需要将test.zip改为game.zip，只需要重新设置文件路径为：/mnt/sdcard/game.zip Aria.download(this).load(DOWNLOAD_URL).setDownloadPath(newPath); 设置队列最大任务数 Aria.get(this).getDownloadConfig().setMaxTaskNum(3); 或 Aria.get(this).getUploadConfig().setMaxTaskNum(3); 设置最大下载速度 制单个任务的上传、下载的最大速度（单位为 kb） Aria.download(this).setMaxSpeed(speed); 最高优先级任务 Aria.download(this).load(DOWNLOAD_URL)``.setDownloadPath(PATH).setHighestPriority(); 将任务设置为最高优先级任务，最高优先级任务有以下特点： 1、在下载队列中，有且只有一个最高优先级任务 2、最高优先级任务会一直存在，直到用户手动暂停或任务完成 3、任务调度器不会暂停最高优先级任务 4、用户手动暂停或任务完成后，第二次重新执行该任务，该命令将失效 5、如果下载队列中已经满了，则会停止队尾的任务，当高优先级任务完成后，该队尾任务将自动执行 6、把任务设置为最高优先级任务后，将自动执行任务，不需要重新调用start()启动任务 设置请求类型 Aria.download(this).load(\"\").setRequestMode(RequestEnum.GET); 或 Aria.upload(this).load(\"\").setRequestMode(RequestEnum.GET); 删除下载记录 第一种删除方式Aria.download(this).load(url).removeRecord(); 或 Aria.upload(this).load(url).removeRecord(); 第二种删除方式/** * 删除任务记录 * * @param type 需要删除的任务类型，1、表示单任务下载。2、表示任务组下载。3、单任务上传 * @param key 下载为保存路径、任务组为任务组名、上传为上传文件路径 */ Aria.get(this).delRecord(type, key); 获取任务实体 HTTP\\FTP单任务下载实体DownloadEntity entity = Aria.download(this).getDownloadEntity(DOWNLOAD_URL); HTTP任务组\\FTP文件夹实体DownloadGroupTaskEntity entity = Aria.download(this).getDownloadGroupTask(mUrls); HTTP\\FTP单任务上传实体UploadEntity entity = Aria.upload(this).getUploadEntity(FILE_PATH); 获取下载的文件大小、当前进度百分比 同样的，你也可以在DownloadTask对象中获取下载的文件大小 @Override public void onTaskRunning(DownloadTask task) { //获取任务文件实体（里面包含文件名，下载地址，保存路径等信息） DownloadEntity entity = task.getEntity(); //获取文件大小 long fileSize = task.getFileSize(); //获取单位转换后的文件大小 String fileSize1 = task.getConvertFileSize(); //当前进度百分比 int percent = task.getPercent(); } 获取当前任务的下载速度 @Override public void onTaskRunning(DownloadTask task) { //如果你打开了速度单位转换配置，将可以通过以下方法获取带单位的下载速度，如：1 mb/s String convertSpeed = task.getConvertSpeed(); //如果你有自己的单位格式，可以通过以下方法获取原始byte长度 long speed = task.getSpeed(); } 设置头参数 对于某些服务器，需要通过添加headler参数才能和服务器进行交互，如果你需要对任务增加header支持，那么你可以 添加一个headler参数Aria.download(this) .load(DOWNLOAD_URL, true) .addHeader(\"key\", \"value\") .save(); 添加一组headler参数Aria.download(this) .load(DOWNLOAD_URL, true) .addHeaders(headlerMap) .save(); 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示：Aria.download(this).loadFtp(URL).addHeader(\"key\", \"value\").save(); 使用服务端提供的文件名 在某些场景下，可能需要使用服务端提供的文件名，那么你可以这么做 Aria.download(SingleTaskActivity.this) .load(DOWNLOAD_URL) .useServerFileName(true) // 使用服务端提供的文件名 .setRequestMode(RequestEnum.GET) .setFilePath(Environment.getExternalStorageDirectory().getPath() + \"/ggsg3.apk\") .start(); 需要注意的是，Aria是从服务器端的content-disposition字段获取文件名，content-disposition对应的value的数据格式必须如下所示，否则获取不到文件名 attachment;filename=xxx // xxx 为文件名 "},"api/linstener_sign_task.html":{"url":"api/linstener_sign_task.html","title":"4.3 只监听单个任务","keywords":"","body":"在Aria中，注解是对应全部任务的，拿onComplete来说，你的下载队列中有3个任务，并且三个任务都已经下载完成，那么onComplete注解就会被调用3次。 这个时候，如果你希望只获取第一个任务A，A的下载地址为（http://aaa.bbb.zip）的完成事件，那么，你可以通过task.getKey().eques(\"http://aaa.bbb.zip\")来判断当前的comple回调是否是A任务，其它注解同理 "},"api/extend_field.html":{"url":"api/extend_field.html","title":"4.4 对任务添加额外信息","keywords":"","body":"保存扩展字段 有的时候，你可能希望在下载的时候存放一些自己的数据，这时你可以调用该接口将数据保存下来（如果你数据比较多，或者数据比较复杂，你可以先把数据转换为JSON，然后再将其存到Aria的下载实体中） Aria.download(this).load(DOWNLOAD_URL).setExtendField(str); 或 Aria.upload(this).load(DOWNLOAD_URL).setExtendField(str); 读取扩展字段 Aria.download(this).load(DOWNLOAD_URL).getExtendField(); 或 Aria.upload(this).load(DOWNLOAD_URL).getExtendField(); 注意事项 需要注意的是：如果你没有调用start()，stop()等操作方法，那么你需要调用save()才能将头部数据保存进数据库。 如下所示： Aria.download(this).loadFtp(URL).setExtendField(\"扩展字段\").save(); "},"entity/download_entity.html":{"url":"entity/download_entity.html","title":"5.1 DownloadEntity","keywords":"","body":" DownloadEntity字段说明 DownloadEntity为下载文件的载体，里面包含了下载文件的一些关键信息 字段 类型 作用 备注 speed long 速度（单位为：byte） convertSpeed String 转换后的速度（mb/s） 需要在config中配置，如果不配置，则为null str String 扩展字段 扩展字段说明 fileSize long 文件大小（单位为byte） convertFileSize String 单位转换后的文件大小（xxmb） 需要在config中配置，如果不配置，则为null state int 状态 0：失败；1：完成；2：停止；3：等待； 4：正在执行；5：预处理；6：预处理完成；7：取消任务 currentProgress long 当前下载进度（单位为byte） completeTime long 完成时间(时间戳) percent int 进度百分比 如：54% isComplete boolean 是否已经完成 true：任务已完成；false：任务未完成 url String 下载地址 fileName String 文件名 isGroupChild boolean 是否属于组合任务 true：属于组合任务；false：不属于组合任务 redirectUrl String 重定向地址 如果任务没有发生重定向，则为null isRedirect boolean 是否重定向 true：已经重定向；false：没有重定向 downloadPath String 文件保存路径 保存路径是唯一的 groupName String 组合任务组名，任务属于组合任务才有该字段 md5Code String 从返回的head中读取的文件md5信息 head字段为Content-MD5 disposition String 服务返回的文件描述信息 head字段为Content-Disposition serverFileName String 从disposition中读取的文件名 Content-Disposition需要是标准的写法，如：attachment; filename=\"filename.jpg\" "},"entity/group_entity.html":{"url":"entity/group_entity.html","title":"5.2 DownloadGroupEntity","keywords":"","body":" DownloadGroupEntity DownloadGroupEntity为组合任务的载体，里面包含了组合任务的一些关键信息 字段 类型 作用 备注 speed long 速度（单位为：byte） convertSpeed String 转换后的速度（mb/s） 需要在config中配置，如果不配置，则为null str String 扩展字段 扩展字段说明 fileSize long 文件大小（单位为byte） convertFileSize String 单位转换后的文件大小（xxmb） 需要在config中配置，如果不配置，则为null state int 状态 0：失败；1：完成；2：停止；3：等待； 4：正在执行；5：预处理；6：预处理完成；7：取消任务 currentProgress long 当前下载进度（单位为byte） completeTime long 完成时间(时间戳) percent int 进度百分比 如：54% isComplete boolean 是否已经完成 true：任务已完成；false：任务未完成 groupName String 组合任务名 为所有子任务url相加的Md5 alias String 组合任务别名 urls List 所有的子任务地址 dirPath String 组合任务的保存文件夹 subEntities DownloadEntity 任务实体列表 "},"entity/upload_entity.html":{"url":"entity/upload_entity.html","title":"5.3 UploadEntity","keywords":"","body":" UploadEntity UploadEntity为上传文件的载体，里面包含了上传文件的一些关键信息 字段 类型 作用 备注 speed long 速度（单位为：byte） convertSpeed String 转换后的速度（mb/s） 需要在config中配置，如果不配置，则为null str String 扩展字段 扩展字段说明 fileSize long 文件大小（单位为byte） convertFileSize String 单位转换后的文件大小（xxmb） 需要在config中配置，如果不配置，则为null state int 状态 0：失败；1：完成；2：停止；3：等待； 4：正在执行；5：预处理；6：预处理完成；7：取消任务 currentProgress long 当前下载进度（单位为byte） completeTime long 完成时间(时间戳) percent int 进度百分比 如：54% isComplete boolean 是否已经完成 true：任务已完成；false：任务未完成 url String 文件上传路径 fileName String 文件名 isGroupChild boolean 是否属于组合任务 true：属于组合任务；false：不属于组合任务 redirectUrl String 重定向地址 如果任务没有发生重定向，则为null isRedirect boolean 是否重定向 true：已经重定向；false：没有重定向 filePath String 上传的文件路径 保存路径是唯一的 responseStr String 上传完成后服务器返回的数据 "},"entity/download_task_entity.html":{"url":"entity/download_task_entity.html","title":"5.4 DownloadTaskEntity","keywords":"","body":" DownloadTaskEntity DownloadTaskEntity为任务信息 字段 类型 作用 备注 state int 任务状态 0：失败；1：完成；2：停止；3：等待； 4：正在执行；5：预处理；6：预处理完成；7：取消任务 headers Map 请求头信息 只有http类任务才有 charSet String 字符编码 默认为\"utf-8\" requestEnum RequestEnum 请求类型 GET、POST redirectUrl String 重定向地址 http任务发生重定向才有 removeFile boolean 删除任务时，是否删除已下载完成的文件 true： 删除任务数据库记录，并且删除已经下载完成的文件 false：如果任务已经完成，只删除任务数据库记录 未完成的任务，不管true还是false，都会删除文件 code int http状态码 urlEntity FtpUrlEntity ftp登录信息 只有ftp任务才有 url String 下载地址 isGroupTask boolean 是否属于组合任务或ftpdir任务 true：属于；false：不属于 groupName String 属于组合任务，为组合任务名，属于FtpDir任务，为FtpDir文件夹路径 isChunked boolean 是否是chunk模式 true：是，false：不是 entity DownloadEntity 下载任务实体 "},"entity/download_group_task_entity.html":{"url":"entity/download_group_task_entity.html","title":"5.5 DownloadGroupTaskEntity","keywords":"","body":" DownloadGroupTaskEntity DownloadGroupTaskEntity为HTTP组合任务\\FTPdir文件夹任务信息 字段 类型 作用 备注 state int 任务状态 0：失败；1：完成；2：停止；3：等待； 4：正在执行；5：预处理；6：预处理完成；7：取消任务 headers Map 请求头信息 只有http类任务才有 charSet String 字符编码 默认为\"utf-8\" requestEnum RequestEnum 请求类型 GET、POST redirectUrl String 重定向地址 http任务发生重定向才有 removeFile boolean 删除任务时，是否删除已下载完成的文件 true： 删除任务数据库记录，并且删除已经下载完成的文件 false：如果任务已经完成，只删除任务数据库记录 未完成的任务，不管true还是false，都会删除文件 code int http状态码 urlEntity FtpUrlEntity ftp登录信息 只有ftp任务才有 entity DownloadGroupEntity http组合任务\\ftp_dir任务实体 subTaskEntities List[DownloadTaskEntity](http://aria.laoyuyu.me/aria_doc/entity/download_task_entity.html) 对应的下载任务的任务实体 "},"entity/upload_task_entity.html":{"url":"entity/upload_task_entity.html","title":"5.6 UploadTaskEntity","keywords":"","body":" UploadTaskEntity UploadTaskEntity为上传任务的任务信息 字段 类型 作用 备注 state int 任务状态 0：失败；1：完成；2：停止；3：等待； 4：正在执行；5：预处理；6：预处理完成；7：取消任务 headers Map 请求头信息 只有http类任务才有 charSet String 字符编码 默认为\"utf-8\" requestEnum RequestEnum 请求类型 GET、POST redirectUrl String 重定向地址 http任务发生重定向才有 removeFile boolean 删除任务时，是否删除已下载完成的文件 true： 删除任务数据库记录，并且删除已经下载完成的文件 false：如果任务已经完成，只删除任务数据库记录 未完成的任务，不管true还是false，都会删除文件 code int http状态码 urlEntity FtpUrlEntity ftp登录信息 只有ftp任务才有 filePath String 上传文件的文件路径 entity UploadEntity 上传任务实体 "},"entity/ftp_url_entity.html":{"url":"entity/ftp_url_entity.html","title":"5.7 FtpUrlEntity","keywords":"","body":" FtpUrlEntity 字段 类型 作用 备注 remotePath String 远程路径 如：ftp://127.0.0.1:21/download/AriaPrj.zip remetePath便是：download/AriaPrj.zip account String 账号 url String 原始url protocol String ftp协议 ftp user String 登录的用户名 password String 登录密码 port String 端口 hostName String 主机域名 needLogin boolean 是否需要登录 true：需要；false：不需要 validAddr InetAddress 有效的主机地址 "},"other/annotaion_invalid.html":{"url":"other/annotaion_invalid.html","title":"6.1 注解不生效","keywords":"","body":"注解无效、ProxyClassCounter文件未生成注解无效、ProxyClassCounter文件未生成 检查下你的工程中有没有使用apply plugin: 'android-apt'，如果有的话将其转换为annotationProcessor。 检查下annotationProcessor 和 compile 版本是否一致，不一致的话对导致生成代理文件失败 如果你是Android studio的module中引用的Aria，那么你还需要再app模块中添加同样的导入代码 compile 'com.arialyy.aria:aria-core:{version code}' annotationProcessor 'com.arialyy.aria:aria-compiler:{version code}' 如果以上设置都无效或控制台打印下面的错误 Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. 请在app的build.gradle文件的defaultConfig块中添加以下代码 android { compileSdkVersion 26 buildToolsVersion \"26.0.2\" defaultConfig { .... javaCompileOptions { annotationProcessorOptions { includeCompileClasspath true } } } ... } 如果都不是的话，build文件时，点击as右下角的gradle console窗口，看看报什么错误（如果有错误，可以的话，麻烦在Issues留言给我） "},"other/feedback.html":{"url":"other/feedback.html","title":"6.2 反馈说明","keywords":"","body":"反馈问题反馈问题 如果在使用Aria的过程中遇到问题，请先在issues查找，有没有其它小伙伴以前发起的提问。 如果没有的话，在文档中查找有没有相应的说明。 如果还是有问题的话，麻烦在issues给我留言。 如果你遇到问题，我希望你能在aria_config.xml中添加以下配置，然后把log发给我 在反馈问题的时候，麻烦尽量描述清楚出bug的步骤，越详细越好。如果你能提供错误日志，那就更好了，这样我才能快速定位问题。 "}}